# Abstractly (iter 0)

Abstractly -- *прототип* языка программирования, в котором парсеры являются [объектами первого класса](https://ru.wikipedia.org/wiki/Объект_первого_класса)

## Установка

Склонировать репозиторий и перейти в папку с исходным кодом  
Далее:

```bash
python3 -m venv ./.venv
source ./.venv/bin/activate
pip3 install -r requirements.txt
python3 main.py
```

Если всё сделано правильно, то вы увидите приглашение:
```
.=>
```

После этого можно начинать работу с системой.

## Взаимодействие с системой

### Числа
Abstractly поддерживает работу с числами и операции над ними.

```
.=> 12
`-> 12

.=> 12 + 55
`-> 67

.=> 5!
`-> 120

.=> 1 + 2 * 3
`-> 7

.=> 1 + (4! - 3!) * 2
`-> 37

.=> 3 ** 4
`-> 81.0
```

### Парсеры
Прежде чем создавать парсеры, необходимо понять, как работает система.  
Парсер -- объект, преобразующий текст в [абстрактное синтаксическое дерево](https://ru.wikipedia.org/wiki/Абстрактное_синтаксическое_дерево)  

Основа системы -- парсеры. После того, как пользователь ввёл строку и нажал Enter, 
система получает основной парсер, с помощью которого:

* Разбирает строку (string -> AST)
* Производит вычисление (AST -> result)

#### Базовые
* CharParser -- парсер для строк.  
  ``` `any strig` ```  
* AndParser -- объединяет несколько парсеров.  
  `p1 & p2`
* OrParser -- проверяет каждый парсер  
  `p1 | p2`

Таким образом, чтобы создать парсер, который будет распознавать строки `abc`, `abd`, `abe`, нужно ввести:
```
.=> `ab` & (`c` | `d`)
`-> (`a` & `b` & (`c` | `d`))
```
Парсер вернётся в виде результата.

#### Вычисления
Для того, чтобы производить вычисления, были реализованы следующие парсеры:  
* KeyArgument -- парсер для аргументов  
  `name:<parser>`
* FuncArgument -- парсер для вычислений  
  `<parser> => <expression>`
  
Допустим, мы хотим создать парсер для новой операции `%)`, 
которая будет делать странные вычилсения над двумя числами,
 нужно написать (может выполняться достаточно долгое время!):

```
.=> a:@number & __ & `%)` & __ & b:@number => a / b + a
`-> 
```

где `__` -- любое количество пробельных символов.

Здесь мы увидели первую проблему данной версии -- низкое быстродействие.
В будущих версиях (будем надеяться) данный недостаток будет исправлен.

Для того, чтобы ускорить создание парсера, можно использовать переменные.

#### Переменные

В глобальной области видимости находится словарь с переменными.  
Посмотреть список переменных и их значения можно введя команду:
```
.=> vars_keys()
`-> dict_keys(['hello', 'pi', '@factorial', '@power', '_return_hello', 'vars_keys', 'type', '@number', '@:chars_dict', '@parser', '@@', '@', '@spaces', '__', 'help', '_debug'])
```

Попробуем посмотреть значение переменной:
```
.=> pi
`-> 3.141592653589793

.=> hello
`-> world!
```

Помимо этого, есть возможность использовать встроенные функции:

```
.=> @factorial(5)
`-> 120

.=> @power(3, 4)
`-> 81.0
```

Вместо аргументов можно использовать выражения:

```
.=> @factorial(2 ** 3)
`-> 40320

.=> @power(2 + (3 - 1), (2 ** 2) / 2)
`-> 16.0

.=> @factorial(@power(2, 2))
`-> 24
```

Помимо этого, мы можем задавать новые переменные:

```
.=> new_var = @factorial(5 - 1)
`-> 24

.=> vars_keys()
`-> dict_keys([..., 'new_var'])

.=> new_var + 5
`-> 29
```

Теперь, если вы всё ещё не дождались выполнения выражения из предыдущего параграфа,
попробуем составить его с помощью переменных 
(помните, что парсеры у нас -- объекты первого класса?):
```
.=> _p = a:@number & __ & `%)` & __ & b:@number
`-> ...

.=> _f = _p => a / b + a
`-> ...
```

Итого (на моей машине) 646 секунд против 10.

### Корневые парсеры
В глобальной области видимости присутствуют следующие парсеры:
* `@number` -- парсер для чисел
* `@parser` -- парсер для создания парсеров
* `@spaces` / `__` -- любое количество пробелов
* `@` -- корневой парсер БЕЗ обёрток
* `@@` -- корневой парсер

**Каждый раз** перед тем, как вывести приглашение (`.=>`),
система ищет среди глобальных переменных
корневой парсер `@@`, который будет использовать для разбора введённой строки.  
Можно его вывести:
```
.=> @@
`-> ... a lot of text ...
```

Корневой парсер `@@` оборачивает парсер `@`, который является объединением (OrParser)
`@number`, `@parser` и ещё нескольких неважных на данный момент парсеров.

#### Добавление своих парсеров
Итак, у нас есть парсер `_f`, который добавляет операцию `%)`, 
но перед тем, как её добавить в корневой парсер, нужно выставить приоритет.

Пусть приоритет будет самым высоким 
(это значит, что данная операция будет вычисляться раньше всех):
```
.=> _crazy = [_f / NumberPriority / 0]
`-> ...
```

Теперь мы можем добавить нашу опреацию в корневой парсер:

```
.=> @ |= _crazy
`-> ...

.=> 4 %) 2
`-> 6.0

.=> 4 %) 1 + 1
`-> 6.0
```

#### Замена основного парсера

Аналогично, мы можем присвоить корневому парсеру `@@` иной парсер:
```
.=> @@ = `x`
`-> `x`

.=> x
`-> `x`
```
