# Abstractly 

Пишем язык программирования


## Как?
* Строка приходит в исполнитель
* Исполнитель преобразует строку с помощью парсеров в AST
    * Parser превращает строку в:
      List[возможное AST, оставшаяся строка]
* AST представляет собой граф, у которого:
    * Каждая нода -- часть строки с мета-информацией
    * Мета-информация:
        * Тип парсера
        * Функция, которая выполняется
* AST начинает выполняться, начиная с листьев
    * Функция, которая лежит в парсере, имеет доступ к:
        * Строке в парсере
        * Детишкам
    * Функция выполняется, возвращает значение
    * Когда всё AST выполнилось, мы возвращаем значение из корня
    

### Парсеры
#### Пустой парсер
line ==> [<∅, line>]

#### Парсер символа
✓ line ==> [<`ch`, line[1:]>]
🚫line ==> [<∅, line>]

#### A & B
AY     =A> [<`A_1`, Y>, ..., <`A_k`, Y>] 
BY     =B> [<`B_1`, Y>, ..., <`B_n`, Y>] 

✓ ABC  ==> [<(`A_1` & `B_1`), C>, ..., <(`A_k` & `B_n`), C>]
🚫AXC  ==> [<∅, AXC>]

#### A | B
XZ =A> [<`A_1`, Z>, ..., <`A_k`, Z>]
XZ =B> [<`B_1`, Z>, ..., <`B_n`, Z>]
XZ ==> [<`A_1`, Z>, ..., <`A_k`, Z>, <`B_1`, Z>, ..., <`B_n`, Z>]

#### A repeat from x to y
X =A=> [⍺, β, ...]
 x     y
X           => [<∅, XXXX>]
XXX         => [<⍺⍺, X>, <⍺β, X>, ..., <ββ, X>, <⍺⍺⍺, ∅>, ..., <βββ, ∅>]

#### A?; A+; A*
A?: A repeat from 0 to 1
A+: A repeat from 1 to inf
A*: A repeat from 0 to inf

#### Parser A with Function F
XZ =A> [<`A_1`, Z>, ..., <`A_k`, Z>] 
XZ ==> [<`A_1`:F, Z>, ..., <`A_k`:F, Z>]
