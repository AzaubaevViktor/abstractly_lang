# Abstractly -- TODO

## Основная цель
Создать язык, который позволит менять работу парсера выражений во время исполнения языка.  
Существование такого языка позволит на лету создавать новые языки программирования, 
модифицировать существующие, создавать свои DSL.  
Спустя некоторое время может появиться возможность работать с человеческой речью (с ограничениями, но тем не менее).  
DSL создаются для упрощения взаимодействия человека со сложными структурами и концепциями.

## План действий на первую итерацию
- Реализовать ввод
  - Строки
  - Интерактивный режим
  - Файл
  - Веб-запросы
- Реализовать вывод
  - Логирование, с подпроектами и удобным включением/выключения логов в тестах
  - Поддержка любой реализации вывода определённых данных
  - (будущее) корректная обработка нескольких вариантов парсинга (в инетрактивном режиме позволять, иначе -- нет)
- Парсеры (Ядро)
  - Базовые вещи (Мета-ядро)
    - Отлов рекурсии
    - Сравнение парсеров
    - Хэширование парсеров
    - Базовый парсер
  - EmptyParser
  - CharParser
  - AndParser
  - OrParser
    - Разрешение левой рекурсии
  - RepeatParser
  - KeyArgument
    - Сбор keyargument-ов из других парсеров
  - FuncParser
    - Работа с функциями
  - PriorityParser
    - Получение всех парсеров изнутри других парсеров
  - EndLineParser
  - ContextParser / DictParser
    - Работа с контекстом выполнения / словарями
  - DataSend + DataWait
    - async парсеры, ожидание данных из других частей парсера
- Обработка ошибок
- Executor
  - Ввод
  - Вывод
  - Основной парсер
  - Модули (базовый модуль -- модуль для import)
  - Исходный код
  - NameSpace (ContextDict) для хранения переменных
- Интроспекция
  - @ -- ядро парсеров
  - @@ -- основной парсер
  - @number -- парсер чисел, например
  - @parser -- парсер парсеров
  - @exec -- метод для исполнения строки
  - @executor -- Создание нового executor
    - @executor in:@input out:@output parser:@parser source:@input
  - ...
- Многострочные парсеры
  - Поддержка интерактивным режимом
- Подключаемые модули (`import`) 
  - Сделать базовый модуль, в который что-то будет подключаться
  - Модуль вызывается из Executor
    - Модулю доступен Executor и весь контекст
    - В будущем можно будет создавать sandbox-executor и в него испортировать модуль
  - Модуль имеет свои базовые зависимости из ядра
  - Модуль для работы с `import` -- базовый
  - Подключается только то, что нужно
  - Может работать с питоном
  - DictParser + FuncParser + KeyArgument + CharParser + AndParser + OrParser + Context + EndLineParser
  - Продумать структуру фс, namespace и прочее
  - Организовать как один из подключаемых модулей
  - Для инциализации (например будет программа интерактивный режим -- как модуль)
  - Для чтения файлов
  - Для веб сервера
  - Явное задание public-методов (Как в Руби?)
  
## Вторая итерация
- Переписать на cython/go/etc
- Поддержка многопоточности
- Веб
  - Работа с запросами
  - Работа с socket.io

## Что должно быть в языке
- Доступ к корневому парсеру (например `@@` или `@`)
- Доступ к подпарсерам (например `@number`)
- Возможность создавать парсеры
  - Математические выражения
- Создание функций и исполнимых парсеров
- Подключаемые модули
- Компиляция парсера для ускорения работы
- Namespaces в том или ином виде
- Пакеный менеджер
- Свой сайт

## Проблемы версии 0
- Низкая скорость исполнения     
  **Возможные причины**:  
  - CharParser (постоянное raise при ошибке, очень дорого)  
  - `__eq__` / `__hash__` (неэффективное вычисление)  
  
  **Как исправить**:
  - ⚠️ Не делать raise, просто возвращать пустой парсер.  
  - ⚠️ Продумать изначально, как будет работать сравнение и хэширование    
    Написать тестов  
- Отсутствие адекватного вывода ошибок  
  **Возможные причины**:  
  - Отсутствие понимания, как это вообще сделать  
  
  **Как исправить**:  
  - Собирать все недопарсенные варианты    
  - ⚠️ Показывать пару самых длинных вариантов  
  - Показывать, как можно было бы продолжить  
- Переменные в глобальной переменной  

  **Как исправить**:  
  - Сделать аналог `ContextDict` и использовать его внутри `Executor`
  - ⚠️ **Продумать схему исполнения**
  
- Для создания парсеров нужны дополнительные знания  

  **Как исправить**:
  - ⚠️ Сделать это централизованно, с базовым классом для таких дел  
    Парсер распространяеся как класс, при инициализации которого мы передаём ему дополнительную информацию
- Рекурсия
  
  **Как исправить**:
  - Сделать декоратор для отлова рекурсии
- Параллелизм   
  - Распараллелить OrParser?
    - Общее состояние
- Создание функций
  - Реализовано в попыхах
  - ⚠️ Считывается всё через any_parser, нам нужно ждать информации о другой части парсера
  - Сделать парсеры-источники иноформации
  - Сделать парсеры-приёмники информации (которые ожидают информации)
