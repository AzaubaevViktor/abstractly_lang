# Abstractly -- TODO

## Основная цель
Создать язык, который позволит менять работу парсера выражений во время исполнения языка.  
Существование такого языка позволит на лету создавать новые языки программирования, 
модифицировать существующие, создавать свои DSL.  
Спустя некоторое время может появиться возможность работать с человеческой речью (с ограничениями, но тем не менее).  
DSL создаются для упрощения взаимодействия человека со сложными структурами и концепциями.

## План действий
- Реализовать грамотный ввод
  - Веб-запросы
  - Просто входные данные
  - Файл
  - Интерактивный режим
- Сделать грамотный вывод
  - Логирование, с подпроектами и удобным включением/выключения логов в тестах
  - Поддержка любой реализации вывода определённых данных
  - (будущее) корректная обработка нескольких вариантов парсинга (в инетрактивном режиме позволять, иначе -- нет)
- Парсеры
  - Выписать список необходимых и чётко разделить ответственность
- Не забывать про обработку ошибок!
- Сделать ожидание данных из других частей парсера (нужно для более быстрого создания функций (нужны знания о некоторых моментах))
- Парсеры, работающие с контекстом выполнения
- Возможность использовать силы текущего исполнителя (аналог exec)
- Многострочные парсеры -- как? проверить концепцию на старой версии
- Все parse асинхронные, чё делать
- Подключаемые модули (`import`) (модуль для работы с import -- базовый; подключается только то, что нужно; может работать с питоном) 
  - DictParser + FuncParser + KeyArgument + CharParser + AndParser + OrParser + Context + EndLineParser
  - Продумать структуру фс, namespace и прочее
  - Организовать как один из подключаемых модулей?
  - Для инциализации (например будет программа интерактивный режим -- как модуль)
  - Для чтения файлов
  - Для веб сервера


## Что должно быть в языке
- Доступ к корневому парсеру (например `@@` или `@`)
- Доступ к подпарсерам (например `@number`)
- Возможность создавать парсеры
  - Математические выражения
- Создание функций и исполнимых парсеров
- Подключаемые модули
- Компиляция парсера для ускорения работы
- Namespaces в том или ином виде
- Пакеный менеджер
- Свой сайт

## Проблемы версии 0
- Низкая скорость исполнения     
  **Возможные причины**:  
  - CharParser (постоянное raise при ошибке, очень дорого)  
  - `__eq__` / `__hash__` (неэффективное вычисление)  
  
  **Как исправить**:
  - ⚠️ Не делать raise, просто возвращать пустой парсер.  
  - ⚠️ Продумать изначально, как будет работать сравнение и хэширование    
    Написать тестов  
- Отсутствие адекватного вывода ошибок  
  **Возможные причины**:  
  - Отсутствие понимания, как это вообще сделать  
  
  **Как исправить**:  
  - Собирать все недопарсенные варианты    
  - ⚠️ Показывать пару самых длинных вариантов  
  - Показывать, как можно было бы продолжить  
- Переменные в глобальной переменной  

  **Как исправить**:  
  - Сделать аналог `ContextDict` и использовать его внутри `Executor`
  - ⚠️ **Продумать схему исполнения**
  
- Для создания парсеров нужны дополнительные знания  

  **Как исправить**:
  - ⚠️ Сделать это централизованно, с базовым классом для таких дел  
    Парсер распространяеся как класс, при инициализации которого мы передаём ему дополнительную информацию
- Рекурсия
  
  **Как исправить**:
  - Сделать декоратор для отлова рекурсии
- Параллелизм   
  - Распараллелить OrParser?
    - Общее состояние
- Создание функций
  - Реализовано в попыхах
  - ⚠️ Считывается всё через any_parser, нам нужно ждать информации о другой части парсера
  - Сделать парсеры-источники иноформации
  - Сделать парсеры-приёмники информации (которые ожидают информации)
